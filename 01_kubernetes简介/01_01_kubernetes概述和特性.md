
# 1 部署发展历程

我们的项目部署也在经历下面的这样一个历程

> 传统部署 -> 虚拟化部署时代 -> 容器部署时代

![](image/Pasted%20image%2020240219105932.png)


- **传统部署时代**：早期，组织在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。例如，如果在物理服务器上运行多个应用程序，则可能会出现-一个应用程序占用大部分资源的情况，结果可能导致其他应用程序的性能下降。--种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且组织维护许多物理服务器的成本很高。
- **虚拟化部署时代**：作为解决方案，引入了虚拟化功能，它允许您在单个物理服务器的CPU.上运行多个虚拟机（VM）。虚拟化功能允许应用程序在VM之间隔离，并提供安全级别，因为一一个应用程序的信息不能被另一应用程序自由地访问。因为虚拟化可以轻松地添加或更新应用程序、降低硬件成本等等，所以虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性。每个VM是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。
- **容器部署时代**：容器类似于VM，但是它们具有轻量级的隔离属性，可以在应用程序之间共享操作系统 （OS），因此，容器被认为是轻量级的。容器与VM类似，具有自己的文件系统、CPU、内存、进程空间等。由于它们与基础架构分离，因此可以跨云和OS分发进行移植。

容器因具有许多优势而变得流行起来。下面列出了容器的一些好处：

- 敏捷应用程序的创建和部署：与使用VM镜像相比，提高了容器镜像创建的简便性和效率。
- 持续开发、集成和部署：通过简单的回滚（由于镜像不可变性），提供可靠且频繁的容器镜像构建和部署。
- 关注开发与运维的分离：在构建/时而不是在部署时创建应用程序容器镜像，将应用程序与基础架构分离。
- 可观察性：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。
- 跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。
- 云和操作系统分发的可移植性：可在Ubuntu、RHEL、RHEL、CoreOS、本地、Google Kubernetes Engine和其它任何其它地方运行。
- 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行OS到使用逻辑资源在OS上运行应用程序。
- 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分，并且可以动态部署和管理-而不是在一台大型单机上器体运行。
- 资源隔离：可预测的应用程序性能。


  

- 传统部署时代：
- ① 在物理机服务器上运行应用程序。
- ② 无法为应用程序定义资源边界。
- ③ 导致资源分配问题。

如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况下，会导致其它应用程序的性能下降。一种解决方案就是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展，并且维护许多物理服务器的成本也很高。

- 虚拟化部署时代：
- ① 作为解决方案，引入了虚拟化。
- ② 虚拟化技术允许在单个物理服务器的 CPU 上运行多个虚拟机（VM）。
- ③ 虚拟化允许应用程序在 VM 之间隔离，并提供一定程序上的安全。
- ④ 一个应用程序的信息不会被另一个应用程序随意访问。
- ⑤ 虚拟化技术能够更好的利用物理服务器上的资源。
- ⑥ 因为可以很轻松的添加或更新应用程序，所以可以实现更好的可伸缩性，并且可以降低硬件成本。
- ⑦ 每个 VM 都是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括自己的操作系统等。

  

缺点：虚拟层冗余，导致资源浪费和性能下降。
- 容器化部署时代：
- ① 容器类似于 VM ，但是可以在应用程序之间共享操作系统。
- ② 容器被认为是轻量级的。
- ③ 容器和 VM 类似，具有自己的文件系统、CPU 、内存、进程空间等。
- ④ 由于容器和基础架构分离，因为可以很方便的进行跨云和跨 Linux 发行版进行移植。
- ⑤ 参照 Docker 的隔离原理（namespace 6 项隔离和 cgroups 8 项资源限制）。

  

容器的优势：
- ① `敏捷性`：敏捷应用程序的创建和部署；和使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。
- ② `及时性`：持续开发、集成和部署；通过快速简单的回滚（由于镜像的不可变性），支持可靠且频繁的容器镜像的构建和部署。
- ③ `解耦性`：关注开发和运维的分离；在构建、发布时创建应用程序的容器镜像，而不是在部署的时候，从而将应用程序和基础架构分离。
- ④ `可观测性`：不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其它指标信号。
- ⑤ `跨平台`：跨开发、测试和生产的环境一致性；在便捷式的计算机上和在云上相同的运行。
- ⑥ `可移植`：跨云和 Linux 发行版本的可移植性；可以在 Ubuntu、CentOS、RedHat、本地、Google Kubernetes Engine 和其他任何地方运行。
- ⑦ `简易性`：以应用程序为中心的管理；提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。
- ⑧ `大分布式`：松散耦合、分布式、弹性、解放的微服务；应用程序被分解成较小的独立部分，并且可以动态的部署和管理 --- 而不是在一台大型单机上整体运行（垂直扩展是有上限的）。
- ⑨ `隔离性`：资源隔离；可预测应用程序性能。
- ⑩ `高效性`：资源利用；高效率和高密度。


# 2 容器化问题

- ① 弹性的容器化应用管理。
- ② 强大的故障转移能力。
- ③ 高性能的负载均衡访问机制。
- ④ 便捷的扩展。
- ⑤ 自动化的资源监测。
- ……




# 3 云原生定义 
以容器为载体，基于微服务架构思想的一套技术体系和方法论

Kubernetes 是 CNCF 托管的第一个开源项目。因此现在提到云原生，往往我们都把它与kubernetes联系起来。

- **通俗解释**
使用Java、Go、PHP、Python等语言开发的应用我们称之为原生应用，在设计和开发这些应用时，使他们能够运行在云基础设施(或kubernetes)上，从而使应用具备可弹性扩展的能力，我们称之为云原生应用。我们可以将云原生理解为以容器技术为载体、基于微服务架构思想的一套技术体系和方法论。

- **官方定义**
云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。

这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。


# 4 服务网格

[服务网格 (Service Mesh)](https://gitee.com/link?target=https%3A%2F%2Fjimmysong.io%2Fblog%2Fwhat-is-a-service-mesh%2F) 用于管理服务之间的网络流量，是云原生的网络基础设施层，也是 [Kubernetes 次世代的云原生应用](https://gitee.com/link?target=https%3A%2F%2Fjimmysong.io%2Fblog%2Fpost-kubernetes-era%2F) 的重要组成部分。

服务网格利用容器之间的网络设置来控制或改变应用程序中不同组件之间的交互。下面，我们用一个例子来说明。假设你想测试 Nginx 的新版本，检查它是否与你的 Web 应用兼容。你用新的 Nginx 版本创建了一个新的容器 (Container2)，并从当前容器 (Container1) 中复制了当前的 Nginx webserver 配置。但你不想影响组成 web 应用的其他微服务（假设每个容器对应一个单独的微服务）—— 就是 MySQL 数据库、Node.js 前端、负载均衡器等。

所以使用服务网格，你可以立即只把 webserver 微服务改成 Container2（新 Nginx 版本的那个）进行测试。如果确定它不能工作，比如因为它导致网站出现一些兼容性问题，那么你就调用服务网格来快速切换回原来的 Container1。而这一切都不需要对其他容器进行任何配置变更 —— 这些变更对其他容器是完全透明的。

如果没有服务网格，对容器来说这项工作将十分繁琐，因为这涉及到逐一更改所有其他容器上的配置，将它们所包含的服务从 Container1 指向 Container2，然后在测试失败后，将它们全部改回来。

在前面这部分 Kubernetes 指南中，我们介绍了一些与 Kubernetes 网络相关的概念。Kubernetes 中的网络可能很棘手，很难理解，如果你刚刚开始，你可能需要一些实践来理解这里。关于服务网格的更多内容请参考 [《Istio 服务网格》](https://gitee.com/link?target=https%3A%2F%2Fjimmysong.io%2Fistio-handbook%2F)。


# 5 K8S概述

kubernetes，简称K8s，是用8 代替8 个字符“ubernete”而成的缩写。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes 提供了应用部署，规划，更新，维护的一种机制。

传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移植性。

新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的。

> 总结：
> 
> - K8s是谷歌在2014年发布的容器化集群管理系统
> - 使用k8s进行容器化应用部署
> - 使用k8s利于应用扩展
> - k8s目标实施让部署容器化应用更加简洁和高效


Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes 能够进行应用的自动化部署和扩缩容。在Kubernetes 中，会将组成应用的容器组合成一个逻辑单元以更易管理和发现。

Kubernetes 积累了作为Google 生产环境运行工作负载15 年的经验，并吸收了来自于社区的最佳想法和实践。


## 5.1 为什么使用 Kubernetes/Kubernetes的优点

- 容器是打包和运行应用程序的最佳方式，在生产环境中，我们需要管理运行应用程序的容器，并且确保这些容器不会停机。如果一个容器发生了故障，则需要手动启动另一个容器，太麻烦了；如果有一个系统能够帮助我们处理这些行为，是不是会很方便？
- Kubernetes 就能解决上面提出的一系列的问题。Kubernetes 为我们提供了一个可弹性运行的分布式系统的框架，Kubernetes 可以满足我们的扩展要求、故障转移、部署模式等，如：Kubernetes 可以轻松管理系统的 Canary（金丝雀） 部署。
- Kubernetes  为我们提供下面的功能：
- ① `服务发现和负载均衡`：Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大，Kubernetes 可以负载均衡并分配网络流量，从而使得部署稳定。
- ② `存储编排`：Kubernetes  允许我们自动挂载自己选择的存储系统，如：本地存储、公有云提供商等。
- ③ `自动部署和回滚`：我们可以使用 Kubernetes  描述已部署容器的所需状态，Kubernetes 可以以受控的速率将实际状态更改为期望状态，如：我们可以自动化 Kubernetes 来为我们的部署创建新的容器，删除现有容器并将它们的所有资源用于新的容器。
- ④ `自动完成装箱计算`：Kubernetes 允许我们指定每个容器所需要的 CPU 和内存（RAM）。当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。
- ⑤ `自我修复`：Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。
- ⑥ `密钥和配置管理`：Kubernetes 允许我们存储和管理敏感信息，如：密码、OAuth2 令牌和 SSH 密钥。我们可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需再堆栈配置中暴露密钥。


- **服务发现和负载均衡**
Kubernetes 可以使用 DNS 名称或自己的 IP 地址来曝露容器。 如果进入容器的流量很大Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。

- **存储编排**
Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。

- **自动部署和回滚**
你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。也可以是方便的实现[金丝雀部署](https://www.infoq.cn/article/lei4vsfpiw5a6en-aso4)(canary deployment )。

- **自动完成装箱计算**
你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。

- **自我修复**
Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。

- **密钥与配置管理**
Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。

## 5.2 Kubernetes 不是什么?

- Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。
- 由于 Kubernetes 在容器级别而不是在硬件级别运行，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡、日志记录和监视。
- 但是，Kubernetes 不是单体系统，默认解决方案都是可选和可插拔的。 Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。

- Kubernetes：
    - `不限制支持的应用程序类型`：Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。
    - `不部署源代码，也不构建你的应用程序`：持续集成(CI)、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。
    - `不提供应用程序级别的服务作为内置服务`，例如中间件（例如，消息中间件）、 数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存、集群存储系统 （例如，Ceph）。这样的组件可以在 Kubernetes 上运行，并且/或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如， [开放服务代理](https://openservicebrokerapi.org/)）来访问。
    - `不要求日志记录、监视或警报解决方案`。 它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。
    - `不提供或不要求配置语言/系统`（例如 jsonnet），`它提供了声明性 API`， 该声明性 API 可以由任意形式的声明性规范所构成。
    - 不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。
    - 此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 相比之下，Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 如何从 A 到 C 的方式无关紧要，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮、更为弹性和可扩展。

# 6 K8S功能

## 6.1 自动装箱

基于容器对应用运行环境的资源配置要求自动部署应用容器

## 6.2 自我修复(自愈能力)

当容器失败时，会对容器进行重启
当所部署的Node节点有问题时，会对容器进行重新部署和重新调度
当容器未通过监控检查时，会关闭此容器直到容器正常运行时，才会对外提供服务

![](image/Pasted%20image%2020240219110209.png)


如果某个服务器上的应用不响应了，Kubernetes会自动在其它的地方创建一个

![](image/Pasted%20image%2020240219110344.png)

## 6.3 水平扩展

通过简单的命令、用户UI 界面或基于CPU 等资源使用情况，对应用容器进行规模扩大或规模剪裁

> 当我们有大量的请求来临时，我们可以增加副本数量，从而达到水平扩展的效果

当黄色应用过度忙碌，会来扩展一个应用


![](image/Pasted%20image%2020240219110512.png)

## 6.4 服务发现

用户不需使用额外的服务发现机制，就能够基于Kubernetes 自身能力实现服务发现和负载均衡

> 对外提供统一的入口，让它来做节点的调度和负载均衡， 相当于微服务里面的网关？

![](image/Pasted%20image%2020240219110521.png)

## 6.5 滚动更新

可以根据应用的变化，对应用容器运行的应用，进行一次性或批量式更新
> 添加应用的时候，不是加进去就马上可以进行使用，而是需要判断这个添加进去的应用是否能够正常使用

## 6.6 版本回退

可以根据应用部署情况，对应用容器运行的应用，进行历史版本即时回退
> 类似于Git中的回滚

## 6.7 密钥和配置管理

在不需要重新构建镜像的情况下，可以部署和更新密钥和应用配置，类似热部署。

## 6.8 存储编排

自动实现存储系统挂载及应用，特别对有状态应用实现数据持久化非常重要
存储系统可以来自于本地目录、网络存储(NFS、Gluster、Ceph 等)、公共云存储服务

## 6.9 批处理

提供一次性任务，定时任务；满足批量数据处理和分析的场景





