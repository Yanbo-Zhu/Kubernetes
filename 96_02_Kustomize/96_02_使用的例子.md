

# 1 例子1 

https://izsk.me/2020/07/01/Kubernetes-kustomize/

## 1.1 目录结构

app-kustomize是一个代码git， 以golang为主，这里只列出了跟kustomize有关的文件,其它代码文档没有直接关系就先省略了.
```
app-kustomize  
	deploy  
		base  
			config.yaml  
			deployment.yaml  
			service.yaml  
			kustomization.yaml   
		overlay  
			1box  
				1box-custom-env.yaml  
				kustomization.yaml  
			prod  
				deployment-patch.yaml  
				kustomization.yaml
```



这里对上述的文件做个简要说明:

`base`翻译过来就是基础的意思， 里面的资源可以理解为默认的配置或者是基础配置

`overlay`目录下则可以根据不同环境建立不同的文件夹, 比如我有一个测试环境,那么可以叫1box(这个名字随便), 还有一个生产环境，就叫prod, 这两个目录下都包含有`kustomeization.yaml`, 同时，两个目录下都可以通过**打patch或者覆盖**的方式来对base目录下对应的资源进行更新, 这也是overlay的由来.

使用`kustomize build ~/ldap/overlays/1box`来生成合并后的整体配置文件
再通过`kustomize build ~/ldap/overlays/1obx | kubectl apply -f -`进行发布到对应的环境中去

当然,这个流程就可以跟CI/CD进行结合使用了. 是不是非常简单.

其它的配置文件不需要过多解释了.


----
`cat base/deployment.yaml`

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: p-expoter-kustom
spec:
  replicas: 1
  template:
    spec:
      containers:
      - args:
        - -TEST
        - "789"
        image: localhost:5055/p-expoter:master-36cd406f
        imagePullPolicy: IfNotPresent
        name: p-expoter
        volumeMounts:
        - mountPath: "/etc/config/config.yml"
          name: demo-config
          readOnly: true
          subPath: config.yml
      imagePullSecrets:
      - name: realty
      volumes:
      - secret:
          items:
          - key: alertmanager.yaml
            path: config.yml
          secretName: p-expoter-senserealty-cms
        name: demo-config
```


---
`cat base/service.yaml`
```
apiVersion: v1  
kind: Service  
metadata:  
  name: p-expoter  
spec:  
  ports:  
  - name: http  
    port: 80  
    targetPort: 80  
  type: ClusterIP
```


---
`cat config.yaml`

```
apiVersion: secrets.mz.com/v1alpha1  
kind: ConfigMapSecret  
metadata:  
  name: p-expoter-senserealty-cms  
spec:  
  template:  
    metadata:  
      name: p-expoter-senserealty-cms   
    data:  
      alertmanager.yaml: |  
          global:  
            resolve_timeout: 5m  
            mongodb_password: $(MONGODB_PASSWORD)  # 在 Var中定义  
            redis_password: $(REDIS_PASSWORD)  
            # special_how: $(CONFIGMAP_HOW)   
            # special_type: $(CONFIGMAP_TYPE)  
          route:  
            receiver: default  
            group_by: ["alertname", "job", "team"]  
            group_wait: 30s  
  vars:  
    - name: MONGODB_PASSWORD  
      secretValue: # 引用secret   
        name: senserealty-secret-data # secret 名字  
        key: mongodb_password # secret key  
    - name: REDIS_PASSWORD   
      secretValue:  
        name: senserealty-secret-data  
        key: redis_password  
    # - name: CONFIGMAP_HOW # 引用configmap  
    #   configMapValue:  
    #     name: special-config-hmmg28f4kd  
    #     key: special.how  
    # - name: CONFIGMAP_TYPE  
    #   configMapValue:  
    #     name: special-config-hmmg28f4kd  
    #     key: special.type
```


以上配置文件都是很常用的资源对象， 这里解释一下config.yaml并不是我们常用的configmap.yaml类型, 而是使用了CRD类型，主要是为了实现敏感信息的加密保存在git上.这块不是这篇post的重点,感兴趣的话, 大家可参考这篇[post](https://izsk.me/2020/06/28/Kubernetes-configmap-reference-var-from-secret/) ，目前可直接把这个当做为等同于configmap

## 1.2 kustomization.yaml

可以发现在base目录或者是overlay目录下都有一个kustomization.yaml文件，该文件是kustomize的核心， 包含了需要部署的资源.

当然它本身是有一定语法的, 详细的使用可参考[这里](https://kubernetes-sigs.github.io/kustomize/api-reference/glossary/#kustomization)，下面会挑选一些常用的配置来说明如何使用

`cat kustomization.yaml`

```
apiVersion: kustomize.config.k8s.io/v1beta1  
kind: Kustomization  
  
commonLabels:  
  k8s-app: p-expoter # 会在所有的资源对象上都会加上该label  
namespace: stage # 会在所有的资源对象上都指定该ns  
  
# configMapGenerator:   # secretGenerator  
# - name: special-config  
#   files:  
#     - configmap.yaml  

resources:  
  - config.yaml  
  - service.yaml  
  - deployment.yaml
```


### 1.2.1 resources
这个字段包含需要部署的资源文件， 这个应该很容易理解


### 1.2.2 commonLables/commonAnnotations
指定了commonLables的话， 则会在所有的资源resources包含的对象上都会加上该label， 支持指定多个，这样就省去了对k8s的yaml中手工地指定label
commonAnnotations同理.


### 1.2.3 namespace
同上

### 1.2.4 configMapGenerator/secretGenerator
这两者具有相同的功能, 可以从文件中直接生成configmap或者是secret
格式如上代码所示，这部分也会渲染到最终的yaml文件中， 因此，**除了resources指定的资源外, 还能通过这种方式生成部署对象**


### 1.2.5 patchesStrategicMerge
patchesStrategicMerge则主要是用于**overlay下的kustomization.yaml中**, 用于使用打patch的方式将该字段指定的文件合并到base目录下对应的内容上.
比如, 现在需要1box环境中，在base声明的deployment.yaml的基础上，给`p-expoter`容器增加一个环境变量
那么就新增overlay/1box/1box-custom-env.yaml

```
apiVersion: apps/v1  
kind: Deployment  
metadata:  
  name: p-expoter-kustom  
spec:  
  template:  
    spec:  
      containers:  
        - args:  
          - "aaabbb"  
          name: p-expoter # 由于env是在spec.template.containers下的, 因此需要保留这种树型的结构，同时容器的名字很重要，需要与base/deployment.yaml对应上，要不然，会出现env找不到容器，自然无法为对应容器添加成功.  
          env:  
            - name: CUSTOM_ENV_VARIABLE  
              value: "Value defined by Kustomize"
```


> 这里需要注意的是，patch的字段都是通过Yaml的层及进行查询的, 所以要添加或者修改的东西一定要对应上层级，==不然在base里是查找不到相应的字段的, 因此也无法修改, 但是不会报错==

`cat overlay/1box/kustomization.yaml`
```
apiVersion: kustomize.config.k8s.io/v1beta1  
kind: Kustomization  
  
# namePrefix: 1box # 所有的资源名称都会加上1box-  
  
# replicas:  # 直接修改资源副本数  
# - name: p-expoter-kustom  
#   count: 2  
  
# images:   # 直接修改镜像  
# - name: localhost:5055/p-expoter:master-36cd406f  # name 为base/deployment中的镜像的名字  
#   newName: p-expoter   
#   newTag: alpine  # 最终会替换成 images: localhost:5055/p-expoter:alpine  
  
bases:  
- ../../base  
  
patchesStrategicMerge: 
- 1box-custom-env.yaml
```


以上的代码实现修改容器的启动参数, 同时为容器添加env的功能

使用`kustomize build deploy/overlay/1box`会发现，p-expoter容器已经被加上了env环境变量了,**而其它的部分保持不变**.
通过patchesStrategicMerge可以实现，**如果指定的字段不存在,则进行添加， 如果存在，则进行覆盖的功能**

**注意**: 
>如果通过在`kustomization.yaml`修改了同时又使用`patchesStrategicMerge`进行了同一字段的修改, 结果以`kustomization.yaml`中的为准 
比如修改replicas, 如果在`kustomization.yaml中修改成了2， 在`patchesStrategicMerge`又修改成了10` , 结果以`kustomization.yaml`中的为准，也就是最终replicas = 2

### 1.2.6 namePrefix/nameSuffix

这两个实现给所有的资源的名字加上前缀或者后缀，以`-`进行隔离， 非常容易理解，主要用于overlay下
常用的也就这些了，还有一些其它的配置就不一一介绍了，官网上都非常的详细.

## 1.3 部署

通过上面的介绍，应该对kustomize有个初步的了解， 最后的工作就是根据不同的环境将资源发布到集群中

1 
kubectl apply -k ~/ldap/overlays/1box

注意:

如果 `kubectl apply -k 出现error: rawResources failed to read Resources`的错误
```
error: rawResources failed to read Resources: Load from path ../../base/ failed: '../../base/' must be a file (got d='/Users/zhoushuke/git_uni/gitlab.bj.sensetime.com/gitlabci-golang-demo/deploy/base')
```

出现这种情况是因为`kustomize`与`kubectl apply -k` 版本不匹配(kubectl的版本其实是跟着集群的版本走的, 而kustomize二进制可能不一定会对着kubectl的版本安装，有可能就直接安装了最新版本)

2 
可以使用`kustomiz build . | kubectl apply -f -`

另外一个情况下, `bases`已经在kustomize v2.1.0+ 版本中给去掉了,高版本的会直接将`bases`转换成`resources`，这个可以从渲染后的kustomization.yaml中看出









